/*
 * generated by Xtext 2.9.0
 */
package mgpl.validation

import mgpl.mGPL.AnimBlock
import mgpl.mGPL.AssStmt
import mgpl.mGPL.AttrAss
import mgpl.mGPL.Complement
import mgpl.mGPL.ElementSelect
import mgpl.mGPL.Expr
import mgpl.mGPL.MGPLPackage
import mgpl.mGPL.MemberSelect
import mgpl.mGPL.Negation
import mgpl.mGPL.NumberLiteral
import mgpl.mGPL.ArrayDecl
import mgpl.mGPL.ObjDecl
import mgpl.mGPL.ParamDecl
import mgpl.mGPL.Prog
import mgpl.mGPL.Touches
import mgpl.mGPL.Var
import mgpl.mGPL.VarDecl
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

import static extension mgpl.Common.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MGPLValidator extends AbstractMGPLValidator {
	
/* 
 * ##### Vordefinierte Hilfsfunktionen & globale Variablen.
 * ##### Verwenden Sie diese wenn möglich. 
 * ##### Verwenden Sie ggf. auch die statischen Funktionen der Datei Common.xtend
 * ##### TODOs für @Check Implementierung hier weiter unten!
 */
 
 	// Verschiedene Instanzabfragen 
	// id.eIsProxy ist wahr wenn der Querverweis nicht hergestellt werden kann
	def isUndeclared(Var it) { id === null || id.eIsProxy } //it.id 
	def isArray(Var it) { id.eContainer instanceof ArrayDecl } //mit it.id gelangen wir VarDecl oder ArrayDecl
	def isGame(Var it) { id instanceof Prog }
	def isVariable(Var it) { id instanceof VarDecl }
	def isObject(Var it) { id instanceof ObjDecl }
	def isAnimation(Var it) { id instanceof AnimBlock }
	def isParameter(Var it) { id instanceof ParamDecl }
	def hasMembers(Var it) { // wird aufgerufen bei einem Var-Ausdruck der Form v.h, ohne Array-Index
		isGame || isObject && !isArray || isParameter //möglich isGame(it) oder it.isGame
	}
	
	// zeigt, ob die Variable als Array benutzt wird
	def usedAsArray(Var it) {
		eContainer instanceof ElementSelect && eContainingFeature == MGPLPackage.Literals.VAR__VARIABLE
		/* aliens[1+3], bullets[i] */
	}
	
	// zeigt, ob Var-Instanz als Objekt verwendet wird
	def usedAsObject(Var it) {
		eContainer instanceof MemberSelect
		/*aliens[i].visible = 0; cur_bullet.visible = 0; */
		   
	}
	// wird auf die Operanden von Touches(einmal für left und einmal für right) aufgerufen
	// zeigt, ob der Operand kein graphisches Objekt ist. (also kein circle, triangle, rectangle)
	def isNoGraphicalObject(Var it) {
		it instanceof MemberSelect
		|| if (it instanceof ElementSelect) !variable.isUndeclared && !variable.isObject && variable.isArray
			else !isUndeclared && (!isObject || isArray) && !isParameter
	}
	
	// Die Methode wird für jeden atomaren Operanden aufgerufen, also zweimal bei binären Operatoren.
	// Wenn ein Attribut animation_Block ist, ist es kein Integer, sonst sind alle anderen Attribute Integers
	def isNoInt(Var it) {
		if (it instanceof MemberSelect) memberName.equals('animation_block')
		else if (it instanceof ElementSelect) !variable.isUndeclared && !variable.isVariable && variable.isArray
		else !isUndeclared && (!isVariable || isArray)
	}
	
	val gameAttributes= #['height', 'width', 'speed', 'x', 'y']
	val circleAttributes=#['animation_block', 'radius', 'visible', 'x', 'y']
	val rectTriangleAttributes=#['animation_block', 'height', 'visible', 'width', 'x', 'y']
	
	// liefert die für das übergebene Objekt erlaubten Attribute
	def allowedAttributes(EObject it) {
		if (it instanceof ObjDecl)
			if (type.equals('circle')) circleAttributes
			else rectTriangleAttributes
		else if (it instanceof ParamDecl)
			if (type.equals('circle')) circleAttributes
			else rectTriangleAttributes
		else if (it instanceof Prog) gameAttributes
	}
	
	// dient zur Konstruktion von Fehlermeldungen mit großgeschriebenen Objektarten
	def objectType(EObject it) {
		if (it instanceof ObjDecl) type.capitalize
		else if (it instanceof ParamDecl) type.capitalize
		else if (it instanceof Prog) 'Game'
	}


/* 
 * ##### Vordefinierte @Check Funktion als Orientierungshilfe.
 */

	
	// prüfen, dass Operanden von touches grafische Objekte sind und von allen anderen Operatoren Integers
	@Check
	def checkExpressionOperands(Expr it) {
		if (it instanceof NumberLiteral || it instanceof Var) return;
		if (it instanceof Touches) {
			if (left.isNoGraphicalObject)
				error('This Operand must evaluate to a Circle, Rectangle, or Triangle',
					MGPLPackage.Literals.TOUCHES__LEFT)
			if (right.isNoGraphicalObject)
				error('This Operand must evaluate to a Circle, Rectangle, or Triangle',
					MGPLPackage.Literals.TOUCHES__RIGHT)
		} else if (it instanceof Negation || it instanceof Complement) {
			val feature=eClass.getEStructuralFeature(MGPLPackage.Literals.NEGATION__EXPR.name)
			val expr=eGet(feature)
			if (expr instanceof Var)
				if (expr.isNoInt)
					error('This Operand must evaluate to an int', feature)
		} else {
			val leftFeature=eClass.getEStructuralFeature(MGPLPackage.Literals.EQUALS__LEFT.name)
			val rightFeature=eClass.getEStructuralFeature(MGPLPackage.Literals.EQUALS__RIGHT.name)
			val left=eGet(leftFeature)
			val right=eGet(rightFeature)
			if (left instanceof Var)
				if (left.isNoInt)
					error('This Operand must evaluate to an int', leftFeature)
			if (right instanceof Var)
				if (right.isNoInt)
					error('This Operand must evaluate to an int', rightFeature)
		}
	}

/* 
 * ##### Ihre Implementierung der @Check Funktion für Aufgabe 2.
 */

	@Check
	def checkVar(Var it) {
		//prüfen, ob Objekt/Variable deklariert ist
		if (it instanceof MemberSelect || it instanceof ElementSelect){
			return
		} else {
			if (it.isUndeclared){
				val id = eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__ID.name)
				error('This Variable/Objekt is undeclared', id)	
				}
			}
		
		//prüfen ob als ein Objekt verwendet wird und werden darf
		if (it.usedAsObject){
			if (hasMembers(it)){
				return
			} else {
				val id = eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__ID.name)
				error('This Variable is not an Object ', id)	
			}
		}
	}
 	
 	// Hilfsfunktion
 	def isAllowedAttribute(EObject it, String name){
 		val allowList = it.allowedAttributes
		
		for (allow:allowList){
			if (longAttributeName(name).equals(allow)){
                return true
            }
		}
		return false
 	}
 	
 	
	@Check
	def checkAttributeAssignment(AttrAss it) {
		
		// prüfen, dass Attribut für Objekt erlaubt ist (Aufg. 2. Attribute)
		val attrName = eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__NAME.name)
		val name = eGet(attrName) as String
		
		if (!isAllowedAttribute(it.eContainer, name)){
			error('This is not an allowed Attribute for this Object',attrName)
		}
		
		// prüfen, dass Attribut, das einen langen und einen kurzen Namen haben kann, nur einmal in Objekt belegt wird (Aufg. 2. Attribute)
		val listAttributes = it.eContainer.eContents
		var String listAttributesString = ''
		
		for (variable:listAttributes){
			if (variable instanceof AttrAss) {
				listAttributesString += ' ' + variable.name + ' '
			}
			
		}
		
		if (name.equals('r')){
			if (listAttributesString.contains('radius')) error('No double attributes allowed', attrName)
		} else if (name.equals('w')){
			if (listAttributesString.contains('width')) error('No double attributes allowed', attrName)	
		} else if (name.equals('h')){
			if (listAttributesString.contains('height')) error('No double attributes allowed', attrName)
		} else if (name.equals('radius')){
			if (listAttributesString.contains(' r ')) error('No double attributes allowed', attrName)
		} else if (name.equals('width')){
			if (listAttributesString.contains(' w ')) error('No double attributes allowed', attrName)	
		} else if (name.equals('height')){
			if (listAttributesString.contains(' h ')) error('No double attributes allowed', attrName)
		}
		
		
		// prüfen, dass Grafikobjekt-Attribut animation_block mit dem Namen eines Animation-Handlers belegt wird (Aufg. 2. Bindungen)
		val attrValue = eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__VALUE.name)
		val value = eGet(attrValue)
		
		if (name.equals('animation_block')){
			if (value instanceof Var){
				val anim = value.id
				val obj = it.eContainer
				if (anim instanceof AnimBlock){
					// prüfen, dass der Animation-Handler einen passenden Typ hat (Aufg. 2. Bindungen)	
					val animType = anim.param.type
					if (!(animType.equals('circle')||animType.equals('rectangle')||animType.equals('triangle'))){
						error('Not accepted type for an Animation-Handler', attrName)
					}
					if (obj instanceof ObjDecl){
						if (!(obj.type.equals(animType))){
							error('Animation-Handler must have same type as Object: '+ obj.type, attrName)
						}
					}
				} else {
					error('Animation-Handler expected', attrValue)
				}
			} else error('Animation-Handler expected', attrValue)
		}
			
		
		// prüfen, dass Game-Attribute nur mit konstanten Zahlen belegt werden (Aufg. 2. Attribute)
		if (it.eContainer instanceof Prog){
			if (!(it.value instanceof NumberLiteral)) {
        		error( "Constant Integer expected", attrValue )
        	}
		}
		
		// prüfen, dass das Game-Attribut speed mit einem Wert zwischen 0 und 100 belegt wird (Aufg. 2. Attribute)
		
        
		if (name.equals('speed')) {
			var speedValue = 0
			if (it.value instanceof NumberLiteral) {
            	speedValue = (it.value as NumberLiteral).value
        	} else { 
        		error( "Constant Integer expected", attrValue )
        	}
            if (speedValue <= 0 || 100 <= speedValue) {
                error( "Value out of valid range (0, 100)", attrValue)
            }
        }
		
		
	}

	@Check
	def checkMemberName(MemberSelect it) {
		
		//prüfen, ob ein verwendetes Attribut für das jeweilige Objekt erlaubt ist (Aufg. 2. Bindungen)
		
		val memberName = eClass.getEStructuralFeature(MGPLPackage.Literals.MEMBER_SELECT__MEMBER_NAME.name)
		val name = eGet(memberName) as String
		var obj = it.variable
				if (obj instanceof ElementSelect){
					obj = obj.variable
				}
		val objId = obj.id
		if (!isAllowedAttribute(objId, name)){
			error('This is not an allowed Attribute for this Object',memberName)
		}
		
	}

	@Check
	def checkAnimation_blockAssignment(AssStmt it) {
		// prüfen, dass das Attribut animation_block in einer Zuweisungsanweisung mit dem Namen eines Animation-Handlers 
		// belegt wird und dass dieser einen passenden Typ hat  (Aufg. 2. Bindungen)
		// Bsp.: c.animation_block = a[3] ist unzulässig; richtig: c.animation_block = lead_alien_animate
		val assVar = eClass.getEStructuralFeature(MGPLPackage.Literals.ASS_STMT__VARIABLE.name)
		val variable = eGet(assVar)
		val assValue = eClass.getEStructuralFeature(MGPLPackage.Literals.ASS_STMT__EXPRESSION.name)
		val value = eGet(assValue)
		if (variable instanceof MemberSelect){
			if (variable.memberName.equals('animation_block')){
				if (value instanceof Var){
				val anim = value.id
				var obj = variable.variable
				if (obj instanceof ElementSelect){
					obj = obj.variable
				}
				val objId = obj.id
				if (anim instanceof AnimBlock){
					val animType = anim.param.type
					if (!(animType.equals('circle')||animType.equals('rectangle')||animType.equals('triangle'))){
						error('Not accepted type for an Animation-Handler', assVar)
					}
					if (objId instanceof ObjDecl){
						if (!(objId.type.equals(animType))){
							error('Animation-Handler must have same type as Object: '+ objId.type, assVar)
						}
					}
				} else {
					error('Animation-Handler expected', assValue)
				}
			}
		} 
	}

		
		
	}
	
}
